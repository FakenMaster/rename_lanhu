// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'rename_folder_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$RenameFolderStateTearOff {
  const _$RenameFolderStateTearOff();

// ignore: unused_element
  _Initial initial() {
    return const _Initial();
  }

// ignore: unused_element
  _DirectoryStorage directoryStorage(String spKey, @nullable String directory) {
    return _DirectoryStorage(
      spKey,
      directory,
    );
  }

// ignore: unused_element
  _SelectDirectorySuccess selectDirectorySuccess(
      String spKey, @nullable String directory) {
    return _SelectDirectorySuccess(
      spKey,
      directory,
    );
  }

// ignore: unused_element
  _Valid valid() {
    return const _Valid();
  }

// ignore: unused_element
  _RenameFail renameFail(String failMessage) {
    return _RenameFail(
      failMessage,
    );
  }

// ignore: unused_element
  _RenameSuccess renameSuccess() {
    return const _RenameSuccess();
  }

// ignore: unused_element
  _RenameProcessing renameProcessing() {
    return const _RenameProcessing();
  }
}

/// @nodoc
// ignore: unused_element
const $RenameFolderState = _$RenameFolderStateTearOff();

/// @nodoc
mixin _$RenameFolderState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $RenameFolderStateCopyWith<$Res> {
  factory $RenameFolderStateCopyWith(
          RenameFolderState value, $Res Function(RenameFolderState) then) =
      _$RenameFolderStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$RenameFolderStateCopyWithImpl<$Res>
    implements $RenameFolderStateCopyWith<$Res> {
  _$RenameFolderStateCopyWithImpl(this._value, this._then);

  final RenameFolderState _value;
  // ignore: unused_field
  final $Res Function(RenameFolderState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc
class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'RenameFolderState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements RenameFolderState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$DirectoryStorageCopyWith<$Res> {
  factory _$DirectoryStorageCopyWith(
          _DirectoryStorage value, $Res Function(_DirectoryStorage) then) =
      __$DirectoryStorageCopyWithImpl<$Res>;
  $Res call({String spKey, @nullable String directory});
}

/// @nodoc
class __$DirectoryStorageCopyWithImpl<$Res>
    extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$DirectoryStorageCopyWith<$Res> {
  __$DirectoryStorageCopyWithImpl(
      _DirectoryStorage _value, $Res Function(_DirectoryStorage) _then)
      : super(_value, (v) => _then(v as _DirectoryStorage));

  @override
  _DirectoryStorage get _value => super._value as _DirectoryStorage;

  @override
  $Res call({
    Object spKey = freezed,
    Object directory = freezed,
  }) {
    return _then(_DirectoryStorage(
      spKey == freezed ? _value.spKey : spKey as String,
      directory == freezed ? _value.directory : directory as String,
    ));
  }
}

/// @nodoc
class _$_DirectoryStorage implements _DirectoryStorage {
  const _$_DirectoryStorage(this.spKey, @nullable this.directory)
      : assert(spKey != null);

  @override
  final String spKey;
  @override
  @nullable
  final String directory;

  @override
  String toString() {
    return 'RenameFolderState.directoryStorage(spKey: $spKey, directory: $directory)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DirectoryStorage &&
            (identical(other.spKey, spKey) ||
                const DeepCollectionEquality().equals(other.spKey, spKey)) &&
            (identical(other.directory, directory) ||
                const DeepCollectionEquality()
                    .equals(other.directory, directory)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(spKey) ^
      const DeepCollectionEquality().hash(directory);

  @override
  _$DirectoryStorageCopyWith<_DirectoryStorage> get copyWith =>
      __$DirectoryStorageCopyWithImpl<_DirectoryStorage>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return directoryStorage(spKey, directory);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (directoryStorage != null) {
      return directoryStorage(spKey, directory);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return directoryStorage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (directoryStorage != null) {
      return directoryStorage(this);
    }
    return orElse();
  }
}

abstract class _DirectoryStorage implements RenameFolderState {
  const factory _DirectoryStorage(String spKey, @nullable String directory) =
      _$_DirectoryStorage;

  String get spKey;
  @nullable
  String get directory;
  _$DirectoryStorageCopyWith<_DirectoryStorage> get copyWith;
}

/// @nodoc
abstract class _$SelectDirectorySuccessCopyWith<$Res> {
  factory _$SelectDirectorySuccessCopyWith(_SelectDirectorySuccess value,
          $Res Function(_SelectDirectorySuccess) then) =
      __$SelectDirectorySuccessCopyWithImpl<$Res>;
  $Res call({String spKey, @nullable String directory});
}

/// @nodoc
class __$SelectDirectorySuccessCopyWithImpl<$Res>
    extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$SelectDirectorySuccessCopyWith<$Res> {
  __$SelectDirectorySuccessCopyWithImpl(_SelectDirectorySuccess _value,
      $Res Function(_SelectDirectorySuccess) _then)
      : super(_value, (v) => _then(v as _SelectDirectorySuccess));

  @override
  _SelectDirectorySuccess get _value => super._value as _SelectDirectorySuccess;

  @override
  $Res call({
    Object spKey = freezed,
    Object directory = freezed,
  }) {
    return _then(_SelectDirectorySuccess(
      spKey == freezed ? _value.spKey : spKey as String,
      directory == freezed ? _value.directory : directory as String,
    ));
  }
}

/// @nodoc
class _$_SelectDirectorySuccess implements _SelectDirectorySuccess {
  const _$_SelectDirectorySuccess(this.spKey, @nullable this.directory)
      : assert(spKey != null);

  @override
  final String spKey;
  @override
  @nullable
  final String directory;

  @override
  String toString() {
    return 'RenameFolderState.selectDirectorySuccess(spKey: $spKey, directory: $directory)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SelectDirectorySuccess &&
            (identical(other.spKey, spKey) ||
                const DeepCollectionEquality().equals(other.spKey, spKey)) &&
            (identical(other.directory, directory) ||
                const DeepCollectionEquality()
                    .equals(other.directory, directory)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(spKey) ^
      const DeepCollectionEquality().hash(directory);

  @override
  _$SelectDirectorySuccessCopyWith<_SelectDirectorySuccess> get copyWith =>
      __$SelectDirectorySuccessCopyWithImpl<_SelectDirectorySuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return selectDirectorySuccess(spKey, directory);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (selectDirectorySuccess != null) {
      return selectDirectorySuccess(spKey, directory);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return selectDirectorySuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (selectDirectorySuccess != null) {
      return selectDirectorySuccess(this);
    }
    return orElse();
  }
}

abstract class _SelectDirectorySuccess implements RenameFolderState {
  const factory _SelectDirectorySuccess(
      String spKey, @nullable String directory) = _$_SelectDirectorySuccess;

  String get spKey;
  @nullable
  String get directory;
  _$SelectDirectorySuccessCopyWith<_SelectDirectorySuccess> get copyWith;
}

/// @nodoc
abstract class _$ValidCopyWith<$Res> {
  factory _$ValidCopyWith(_Valid value, $Res Function(_Valid) then) =
      __$ValidCopyWithImpl<$Res>;
}

/// @nodoc
class __$ValidCopyWithImpl<$Res> extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$ValidCopyWith<$Res> {
  __$ValidCopyWithImpl(_Valid _value, $Res Function(_Valid) _then)
      : super(_value, (v) => _then(v as _Valid));

  @override
  _Valid get _value => super._value as _Valid;
}

/// @nodoc
class _$_Valid implements _Valid {
  const _$_Valid();

  @override
  String toString() {
    return 'RenameFolderState.valid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Valid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return valid();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (valid != null) {
      return valid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return valid(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (valid != null) {
      return valid(this);
    }
    return orElse();
  }
}

abstract class _Valid implements RenameFolderState {
  const factory _Valid() = _$_Valid;
}

/// @nodoc
abstract class _$RenameFailCopyWith<$Res> {
  factory _$RenameFailCopyWith(
          _RenameFail value, $Res Function(_RenameFail) then) =
      __$RenameFailCopyWithImpl<$Res>;
  $Res call({String failMessage});
}

/// @nodoc
class __$RenameFailCopyWithImpl<$Res>
    extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$RenameFailCopyWith<$Res> {
  __$RenameFailCopyWithImpl(
      _RenameFail _value, $Res Function(_RenameFail) _then)
      : super(_value, (v) => _then(v as _RenameFail));

  @override
  _RenameFail get _value => super._value as _RenameFail;

  @override
  $Res call({
    Object failMessage = freezed,
  }) {
    return _then(_RenameFail(
      failMessage == freezed ? _value.failMessage : failMessage as String,
    ));
  }
}

/// @nodoc
class _$_RenameFail implements _RenameFail {
  const _$_RenameFail(this.failMessage) : assert(failMessage != null);

  @override
  final String failMessage;

  @override
  String toString() {
    return 'RenameFolderState.renameFail(failMessage: $failMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RenameFail &&
            (identical(other.failMessage, failMessage) ||
                const DeepCollectionEquality()
                    .equals(other.failMessage, failMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failMessage);

  @override
  _$RenameFailCopyWith<_RenameFail> get copyWith =>
      __$RenameFailCopyWithImpl<_RenameFail>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return renameFail(failMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (renameFail != null) {
      return renameFail(failMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return renameFail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (renameFail != null) {
      return renameFail(this);
    }
    return orElse();
  }
}

abstract class _RenameFail implements RenameFolderState {
  const factory _RenameFail(String failMessage) = _$_RenameFail;

  String get failMessage;
  _$RenameFailCopyWith<_RenameFail> get copyWith;
}

/// @nodoc
abstract class _$RenameSuccessCopyWith<$Res> {
  factory _$RenameSuccessCopyWith(
          _RenameSuccess value, $Res Function(_RenameSuccess) then) =
      __$RenameSuccessCopyWithImpl<$Res>;
}

/// @nodoc
class __$RenameSuccessCopyWithImpl<$Res>
    extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$RenameSuccessCopyWith<$Res> {
  __$RenameSuccessCopyWithImpl(
      _RenameSuccess _value, $Res Function(_RenameSuccess) _then)
      : super(_value, (v) => _then(v as _RenameSuccess));

  @override
  _RenameSuccess get _value => super._value as _RenameSuccess;
}

/// @nodoc
class _$_RenameSuccess implements _RenameSuccess {
  const _$_RenameSuccess();

  @override
  String toString() {
    return 'RenameFolderState.renameSuccess()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RenameSuccess);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return renameSuccess();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (renameSuccess != null) {
      return renameSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return renameSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (renameSuccess != null) {
      return renameSuccess(this);
    }
    return orElse();
  }
}

abstract class _RenameSuccess implements RenameFolderState {
  const factory _RenameSuccess() = _$_RenameSuccess;
}

/// @nodoc
abstract class _$RenameProcessingCopyWith<$Res> {
  factory _$RenameProcessingCopyWith(
          _RenameProcessing value, $Res Function(_RenameProcessing) then) =
      __$RenameProcessingCopyWithImpl<$Res>;
}

/// @nodoc
class __$RenameProcessingCopyWithImpl<$Res>
    extends _$RenameFolderStateCopyWithImpl<$Res>
    implements _$RenameProcessingCopyWith<$Res> {
  __$RenameProcessingCopyWithImpl(
      _RenameProcessing _value, $Res Function(_RenameProcessing) _then)
      : super(_value, (v) => _then(v as _RenameProcessing));

  @override
  _RenameProcessing get _value => super._value as _RenameProcessing;
}

/// @nodoc
class _$_RenameProcessing implements _RenameProcessing {
  const _$_RenameProcessing();

  @override
  String toString() {
    return 'RenameFolderState.renameProcessing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RenameProcessing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required
        TResult directoryStorage(String spKey, @nullable String directory),
    @required
        TResult selectDirectorySuccess(
            String spKey, @nullable String directory),
    @required TResult valid(),
    @required TResult renameFail(String failMessage),
    @required TResult renameSuccess(),
    @required TResult renameProcessing(),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return renameProcessing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult directoryStorage(String spKey, @nullable String directory),
    TResult selectDirectorySuccess(String spKey, @nullable String directory),
    TResult valid(),
    TResult renameFail(String failMessage),
    TResult renameSuccess(),
    TResult renameProcessing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (renameProcessing != null) {
      return renameProcessing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult directoryStorage(_DirectoryStorage value),
    @required TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    @required TResult valid(_Valid value),
    @required TResult renameFail(_RenameFail value),
    @required TResult renameSuccess(_RenameSuccess value),
    @required TResult renameProcessing(_RenameProcessing value),
  }) {
    assert(initial != null);
    assert(directoryStorage != null);
    assert(selectDirectorySuccess != null);
    assert(valid != null);
    assert(renameFail != null);
    assert(renameSuccess != null);
    assert(renameProcessing != null);
    return renameProcessing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult directoryStorage(_DirectoryStorage value),
    TResult selectDirectorySuccess(_SelectDirectorySuccess value),
    TResult valid(_Valid value),
    TResult renameFail(_RenameFail value),
    TResult renameSuccess(_RenameSuccess value),
    TResult renameProcessing(_RenameProcessing value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (renameProcessing != null) {
      return renameProcessing(this);
    }
    return orElse();
  }
}

abstract class _RenameProcessing implements RenameFolderState {
  const factory _RenameProcessing() = _$_RenameProcessing;
}
